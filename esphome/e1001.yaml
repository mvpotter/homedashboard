esphome:
  name: home
  on_boot:
    priority: -10
    then:
      - output.turn_on: bsp_battery_enable
      - logger.log: "on_boot: battery measurement enabled"

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  framework:
    type: esp-idf

psram:
  mode: octal
  speed: 80MHz

logger:
  level: DEBUG

api:
  password: ""

ota:
  - platform: esphome
    password: ""

wifi:
  ssid: "TT_IoT"
  password: "xdkN2iXNrN3w4CPsHo"

  ap:
    ssid: "Home Fallback Hotspot"
    password: "JcwSvS1e3HeW"

  # при каждом пробуждении: подключились к Wi-Fi → один апдейт картинки
  on_connect:
    - logger.log: "WiFi connected, updating dashboard_image"
    - component.update: dashboard_image

captive_portal:

# === DEEP SLEEP: простой и надёжный ===
deep_sleep:
  id: deep_sleep_ctrl
  # сколько работать после пробуждения
  run_duration: 30s
  # сколько спать до следующего пробуждения
  sleep_duration: 5min
  # зелёная кнопка как wakeup
  wakeup_pin:
    number: GPIO3
    allow_other_uses: true
  wakeup_pin_mode: INVERT_WAKEUP

time:
  - platform: sntp
    id: sntp_time
    timezone: Europe/Berlin

# включает делитель для измерения батареи
output:
  - platform: gpio
    pin: GPIO21
    id: bsp_battery_enable

sensor:
  - platform: adc
    pin: GPIO1
    id: battery_voltage
    name: "Battery Voltage"
    attenuation: 12db
    update_interval: 30s
    filters:
      - multiply: 2.0

  - platform: template
    id: battery_level
    name: "Battery Level"
    unit_of_measurement: "%"
    device_class: battery
    state_class: measurement
    lambda: "return id(battery_voltage).state;"
    update_interval: 30s
    filters:
      - calibrate_linear:
          - 4.15 -> 100.0
          - 3.96 -> 90.0
          - 3.91 -> 80.0
          - 3.85 -> 70.0
          - 3.80 -> 60.0
          - 3.75 -> 50.0
          - 3.68 -> 40.0
          - 3.58 -> 30.0
          - 3.49 -> 20.0
          - 3.41 -> 10.0
          - 3.30 -> 5.0
          - 3.27 -> 0.0
      - clamp:
          min_value: 0
          max_value: 100

binary_sensor:
  - platform: gpio
    id: sleep_wakeup_button
    pin:
      number: GPIO3  # Green button
      mode: INPUT_PULLUP
      inverted: true
      allow_other_uses: true
    on_press:
      then:
        - logger.log: "Button pressed (manual sleep 4h)"
        - deep_sleep.enter:
            id: deep_sleep_ctrl
            sleep_duration: 4h

  - platform: gpio
    id: next_button
    pin:
      number: GPIO4  # Right button
      mode: INPUT_PULLUP
      inverted: true
    on_press:
      then:
        - logger.log: "Right button pressed -> reload dashboard"
        - component.update: dashboard_image

  - platform: gpio
    id: prev_button
    pin:
      number: GPIO5  # Left button
      mode: INPUT_PULLUP
      inverted: true
    on_press:
      then:
        - logger.log: "Left button pressed -> reload dashboard"
        - component.update: dashboard_image

# define font to display words
font:
  - file: "gfonts://Inter@700"
    id: myFont
    size: 24
  - file: "gfonts://Roboto Mono@700"
    id: battery_font
    size: 12

# define SPI interface
spi:
  clk_pin: GPIO7
  mosi_pin: GPIO9

http_request:
  verify_ssl: false
  timeout: 20s
  watchdog_timeout: 25s

online_image:
  - id: dashboard_image
    format: BMP
    type: BINARY
    url: http://192.168.3.22:8443/dashboard.bmp
    update_interval: never
    on_download_finished:
      - logger.log: "online_image: download finished"
      - component.update: epaper_display
    on_error:
      - logger.log:
          level: ERROR
          format: "online_image: download or decode error"

display:
  - platform: waveshare_epaper
    id: epaper_display
    model: 7.50inv2
    cs_pin: GPIO10
    dc_pin: GPIO11
    reset_pin:
      number: GPIO12
      inverted: false
    busy_pin:
      number: GPIO13
      inverted: true
    update_interval: never
    lambda: |-
      it.image(0, 0, id(dashboard_image));
      if (!isnan(id(battery_level).state)) {
        it.printf(
          it.get_width() - 4, 2,
          id(battery_font),
          TextAlign::TOP_RIGHT,
          "%.0f%%",
          id(battery_level).state
        );
      }
